\subsection{Smart Contracts}
\label{subsec:approach-smart-contracts}
\subsectionnames{Vincent Jonany, Dukagjin Ramosaj}

\subsubsection*{Technologies}

Our implementation of smart contracts in the Blockchain was done through the Solidity programming language. Solidity being one of the most used contract-oriented high-level programming languages for executing smart contracts. Solidity compiles smart contracts to bytecode which is executable on the Ethereum Virtual Machine (EVM). 

As our development framework in Blockchain, we decided on using Truffle, since its the most popular development framework for Ethereum. Through Truffle we were able to handle the process of compilation, linking, deployment and binary management of smart contracts. In the scope of this project, we decided to start our implementation with the Truffle framework. One of the main reasons was due to the advantage Truffle has in terms of wider and more active community support and the availability of online resources, more than any other Ethereum development framework. Moreover, the possibility of Truffle integration with Node.js became an important and crucial advantage for our implementation due to our team’s advanced skills on JavaScript programming \cite{relatedWork29}.

In order to test our smart contracts on a local blockchain network, we used Ganache. We used Ganache since it provides us with a possibility of simulating the blockchain network, allowing us to make Remote Procedure Calls(RPC) calls in it without the need of actually mining the blocks. Moreover, Ganache provides a nice user interface in which developers can see the details of all the transactions, mining status, costs, and other things to aid them during development and debugging. 

\subsubsection*{Responsibilities}

In addition to performing data integrity checks, and performing the tasks they are programmed to do, it is also the responsibility of the smart contracts to create the new root hash when any data was changed. For example, when the smart contract has finished incrementing a counter value, it is the responsibility of the smart contract to create the new root hash. It can create the new root hash using the proof given for the integrity check (also see section \ref{subsec:mip-generation}) and using the new counter value’s hash value. 

We are able to keep this responsibility in the smart contracts because sending Merkle proofs is not expensive, as it is only sending a fraction of nodes from the whole tree. Recreating the Merkle tree in the integrity check, and creating a new root hash is also not computationally expensive.
