\section{Future Work} \label{sec:future_work}

% \begin{itemize}
% \item Essentially, copy our future work parts from the presentations :)
% \end{itemize}
In this section, we aim to provide the possible future steps that can show and increase the value or the advantages of the off-chaining approach. In the course of our project, we have identified other ways that we could have done to accomplish this. We have also identified other potential integrity check mechanisms that can perform more efficiently, such as paying less gas cost.

\subsection{Translator into Smart Translator}
The current implementation of the “Translator” is at its proof-of-concept stage. However we believe that the reasoning of extending the development of the translator, could become significantly useful and an interesting feature to have, since it can make a decision on whether off-chaining makes sense or not for a given smart contract. In addition to translating the original Smart Contract to its off-chained variant, a future implementation of the Translator could also generate the middleware and database components that would be necessary for the overall system.

\subsection{Client side application offering as library for other DApps}
\subparagraph{Library}
The functionalities of our developed off-chaining solution could be included in Ethereum as a library living on the blockchain. Every developer could make use of these in her Smart Contract then. The library functions could for example include our implemented integrity check mechanisms (e.g. multi-row and multi-column Merkle Tree, compatible with Web3.js) and off-chaining concept (with e.g. events, also general setup for avoiding gas costs through storage).

\subparagraph{Smart Contract to inherit from}
In addition to (or possibly instead of) the library we could provide the Smart Contract as an entity living on the Ethereum blockchain that developers could have their Smart Contracts inherit from and thus include the functions and structure of our implemented off-chaining solution.

\subsection{Make application listen on events publicly and offer contract functions publicly (Multi-User)}
In the current implementation, only the creator of the Smart Contract can trigger its functions and make use of the off-chained data. As the Smart Contract is living on a public blockchain, it would be beneficial to offer the functionalities of one off-chained Smart Contract to the network though and leverage its power in terms of potential applications. There could be contracts that react if called by any network participant or only by an entitled one. Depending on the access rights and the new ways to interact with our system the application scope of the implemented system is broadened widely and could e.g. be used by several team members, all departments in a company or across a collection of organizations within an industry with their respective Ethereum accounts.

\subsection{Derived Ideas from Research on Oraclize}
Could our system be seen as a personal data Oracle? On request, it retrieves the wanted data from outside the blockchain and pushes it on-chain. Not from websites though but from a (Relational) Database (that is either trusted or can be double-checked by the trusted middleware) and through the locally running middleware (not a Third party service).

Could our system function as an Outbound Oracle (or represent a part of it) (https://blockchainhub.net/blockchain-oracles/)?
An example could be a Smart Contract by a company with one of its suppliers that lives on Ethereum. The supplier claims he has delivered the goods to the company by calling the function “requestPaymentForDeliveredGoods” in the Smart Contract. The Smart Contract fires an event to get the invoice data from the company’s database. The company’s middleware gets the data and pushes it into the Smart Contract. The Smart Contract verifies this data (e.g. a contract about the delivered goods) and fires another event. This event could be used by the company’s accounting software to trigger the money transfer to the supplier.

Oracle queries can be encrypted (http://docs.oraclize.it/\#ethereum-advanced-topics-encrypted-queries). Could on-chain encryption of the data thus behave like an integrity check? The Smart Contract stores a magic header, encrypts the data with this magic header (concatenated at the beginning) and the database stores it.
When the Smart Contract needs the data, it requests it and the database provides the needed data. The Smart Contract then decrypts it and controls the magic header (correct decryption, i.e. useful decryption output).
The question arises whether Smart Contracts can decrypt and encrypt, that is without anyone being able to decrypt the encrypted output. This is not yet possible, as the pubkey encryption does not really apply to Smart Contracts (only to user accounts). Much research is going on in this direction.

On conflict between data from the database and the stored hash on the blockchain we could issue “Data Discrepancy Forms” to be resolved by the user manually later on.

\subsection{Randomized Sampling}
Another idea that we derived from our initial research on integrity check mechanisms is the Randomized Sampling approach. This could be used for query completeness as well as for integrity checks.
To reduce the gas costs, a random sample from the query results that the database returns could be drawn and then verified by the blockchain. In contrast, in our proof of concept implementation for query completeness every record is looked at on-chain.
In a similar fashion, the Randomized Sampling could be used as an integrity check mechanism that trades less security against decreased gas costs. When the Smart Contract requests the off-chained data all of that data is currently checked afterwards on-chain (which is costly). Again, a random sample could be drawn from the off-chained data that is handed to the Smart Contract and only that random sample is verified. The user of the system could be offered the choice whether she wants a full integrity check performed or a Randomized Sampling.

\subsection{Integrate more efficient and new integrity checks}
\subparagraph{Encryption-Based (Jacob Eberhardt, Slide Deck Strategies, p. 7)}
Instead of hashing, the data could also be encrypted (i.e. signed by the user) and could thus not be modified in any meaningful way. It could be relatively easy and efficient to perform integrity checks in this way.
This could follow a similar implementation structure as with the hashing and Merkle Tree beforehand; first a whole row is encrypted and can thus be checked. Then, a more sophisticated mechanism (like a Merkle Tree for encryption) could be built on top of that.

\subparagraph{Beyond}
With more research in the field and more experience further ideas beyond the presented and implemented ones could arise and prove themselves as good candidates for integrity check mechanisms.

\subsection{Add a more user-friendly front-end for the auto off-chaining of smart contracts}
The user experience could be enhanced with an actual user interface for the user to interact with when she wants to create off-chained contracts, call other Smart Contract functions or have verified queries. Currently, this is done via Postman calls.

\subsection{Make use of a more optimized database for Merkle Trees}
One of the steps which were originally thought of was to integrate a specifically optimized database for the storing of our Merkle Tree structures, this in order to save on memory and processing within the flows which make use of the Merkle Tree.
In our current implementation it would not have had much of an effect since we used relatively small Merkle Trees for our use cases and demos, however it is not the most efficient since we re-create the Merkle Tree whenever necessary, rather than storing it somewhere and updating it.
Possible optimizations to the way our information is stored in the Merkle Tree are also theoretically possible, for example, regarding how items are stored in the Merkle Tree, dividing our datasets into different size groups and mapping them differently, for example according to how often they are accessed.
The main potential improvement would be to use a graph database.

\subsection{Make Middleware Trustless}
By deploying the now trusted locally hosted middleware as a dapp we could make it trustless (as the blockchain). It could e.g. be hosted on a decentralized database like IPFS and listen to the events fired by an off-chained Smart Contract. This could enable further applications domains and allow certain user groups to build more trust in our solution. For example, a financial auditor that knows that the middleware used in the Financials use case is hosted in a trustless environment is assured that the company was not able to apply any accounting tricks based on the code in the middleware. Also, this approach could enable us to bring the implemented solution into the hands of more users and offer it as a service to them.

\subsection{Oraclize Approach to Save Gas}
During our research about alternative approaches to check the integrity of the off-chained data, we analyzed the Oracle provider Oraclize (see part 3.2) and found an approach that Oraclize uses to save gas costs which could present a further opportunity to extend this project’s system as well. By giving its users the choice whether to provide the proof that the data pushed by their Oracle is correct to the Smart Contract that requested the data in the first place and that may want to run the integrity check before actually using it or to store the proof for later use on a trustless database (IPFS) Oraclize can save its users a lot of gas in contrast to running the proof of correct data on-chain every time data is pushed to a Smart Contract. Accordingly, the presented system in this paper could provide its users with the same choice and further improve on its goal to save gas. At the same time, the integrity of the data can still be secured.

\subsection{Mature Query Completeness (Jacob Eberhardt, Slide Deck Strategies, p. 9)}
The full benefit of the Merkle Tree Integrity check mechanism will reveal itself once our implementation supports an even more profound query functionality. Currently, the functions of the Smart Contract can be executed and the integrity of the needed data for them is checked but the correct execution of queries to the database can only be verified for the implemented proof of concept (queries for date range). The query completeness could be broadened to assured any query by the blockchain as well. This includes the Smart Contract capabilities to check that the returned query results (by the database) were not modified, that the returned results match the query predicate, that the records that were not returned do not match the query predicate and that the sum of the two sets (returned and not returned) equals to the right amount of stored records.
When it comes to benchmarking, it would be interesting to find a limit for the rows that can be checked in this way. Every number bigger than that one needs to cope with compromises concerning query completeness (e.g. only checking that all rows were considered and are part of the table but no actual value checking) because of the high costs and the off-chaining of data constraint.

\subsection{Merkle DAG}
\subparagraph{Concept}
Merkle DAG (Directed Acyclic Graph) is one of the features that we included into our potential roadmap after the mid-term presentation. However, due to the limited time and resources we have, we decided to prioritize other things in the roadmap.

The data structure compatible in the application side will affect the complexity of the use cases that we can handle. However, at the same time, we also try to not tremendously increase the gas cost. The Merkle DAG increases our complexity of the data structure from a binary tree to a directed acyclic graph. It allows us to have a more complex relationship. For example, we could create a complex Role Based Access management application that leverages the Smart Contract to maintain the integrity of the hierarchy status of each role.

We could of course implement other data structure that allows more complex behavior, however as mentioned previously, we want to keep the gas cost considerable. Hence, the second requirement requirement is that the data structure has to have an efficient integrity check mechanism. As the name suggests, Merkle DAG also implies the similar Merkle proofing mechanism that a Merkle tree has. Hence, an integrity check on the root hash, to make sure that the children have not been changed is efficient as well.

Such complexity and a level of efficiency in the data integrity check this mechanism provides can provide higher values to the users. Hence, incentivizing them to use the off-chaining approach in comparison to the traditional approach.

\subparagraph{Related Works}
Over the past few years, some papers have been published in regards to extending the Merkle hash technique from just trees but to other data structures, such as directed acyclic graphs. <http://truthsayer.cs.ucdavis.edu/model.12.6.pdf> In addition to that, another paper has been published in regards to a revised hashing technique for directed acyclic graphs <https://eprint.iacr.org/2012/352.pdf>. The paper suggests that the traditional Merkle hashing technique is not suitable for a more complex data structure, such as the directed acyclic graph. And lastly, the closest work to a proof of concept for Merkle DAG <https://github.com/jbenet/random-ideas/issues/20>.  //TODO Cite stuff

\subsection{Potential Additional Features}
Depending on the data and its format a different database could be chosen (automatically by the middleware), e.g. Relational or NoSQL. Specifically, an optimized database for storing the Merkle Proof could increase performance.

Additional Database access control mechanisms could be included.

The user could specify if and which kind of blockchain guarantees she wishes to have for the data she wants to store (e.g. blockchain needed at all?, which integrity check?).
A remote database (in place of the currently local one) can be integrated into the implementation. This could simulate the case that the user does not control the database herself and lead to further refinements of our solution.

The database could sign the records it stored and the user may keep these as proof that the records once existed in the database (proof of existence, in case the database provider denies that the database ever knew about a record). (Jacob Eberhardt, Slide Deck Strategies, p. 7)

We could optimize the calculation of proofs by placing variables which are used together as neighbours in the merkle tree. Thus, when calculating the merkle root / merkle proof we save on iterations as we can chop more parts of the tree away. Of course, this optimization has its limitation when certain variables get used together with multiple others in different functions. (This could also be done automatically with an AI)
