\subsection{Technologies}


\subsubsection{Smart Contracts, Solidity Truffle and Ganache}

\subparagraph{Smart Contracts} 
Computer programs that are executed automatically when conditions (terms) of the contract have been met. Understanding smart contracts in a high-level aspect are the same as standard contracts. While a standard contract enforces the terms of a contract (regularly by law), a smart contract actualizes this enforcement of terms through network consensus and online cryptography secure systems. These programs are executed in a trustless and carefully designed way in the network and are referred as Smart Contracts. Ethereum is one of the most known platforms, it empowers developers to create their own smart contracts and creating decentralized applications in the blockchain [\cite{Buterin2014}]. Upon creation of smart contracts, they need to be executed in a secured runtime environment. Therefore, an Ethereum Foundation team project developed the Ethereum Virtual Machine (EVM) which is the runtime enviroment for Smart Contracts. Putting it in simpler understanding, EVM is a virtual machine that continues running on every node in the network and executes smart contracts. In addition, it is isolated that no framework or filesystem access is possible, thus, to ensure determinism. One vital part of the way the EVM works is that each and every task that is executed inside the EVM, is executed by each full node. This is a crucial part of the Ethereum 1.0 consensus model and has the advantage that any contract on the EVM can call some other contract at zero cost, however, it also has its disadvantages that the computational steps on the EVM are exceptionally costly [\cite{Buterin2014}]. In order that the Ethereum network is not being abused or being deliberately attacked, the Ethereum protocol charges a fee for every computational step. The way this cost is paid in Ethereum blockchain i’s through the attribute called gas. The fee or the price of the gas is deteremined on market-basis; meaning it is decided by the economic concept of market where supply meets demand among users and miners' willingness to mine the next block in the network (blockchain). Furthermore, understanding the way how fees work, is that every transaction alongside other attributes must contain the 'gasPrice', which is the fee that the transaction pays per unit of gas, and 'startGas' being the maximum amount of unit of gas that you are willing to pay for a transaction. Therefore, at every execution of transaction a prior evaluation of a transaction cost is done [\cite{Buterin2014}].
				\[ gasCost(Tx)= {gasPrice *  startGas}\]
To understand to which extent the usage of the EVM makes sense, it can mainly incorporate running business logic applications ("if this then that"), confirming signatures and other cryptographic objects [\cite{Ethereum2017}. On the other hand, any utilization which incorporates using EVM as a file storage, platform or anything to do with GUI, it does not fit under the reasonable use due to its tremendous costs. Therefore, usage of on-chain code execution with today's blockchain implementations, implies furthest to be at the stage of doing simple programming functions. Nevertheless, in order to be able to use Smart Contracts, higher level programming languages which compile EVM code have been developed such as Solidity, Serpent, LLL.


\subparagraph{Solidity}
Being as one of the most used contract-oriented high-level programming language for executing smart contracts. It was inspired by C++, Python, and JavaScript and is intended to focus on the Ethereum Virtual Machine (EVM). Solidity is compiled to bytecode that is executable on the EVM. Through Solidity, developers can write applications that enable self-enforcing business rationale exemplified in smart contracts, leaving an unchangeable and definitive record of transactions. Solidity is a statically typed, which inheritance is supported, libraries and complex user characterized types among other features.[citation]

\subparagraph{Truffle}
The most popular development framework for Ethereum. It is written in JavaScript, therefore, being more flexible and providing numerous built-in features that assist and make the development easier. Truffle aims to handle the process of compilation, linking, deployment and binary management of smart contracts. Furthermore, it supports network management for deployment to private and public networks, its interactive console – which provides access to your built-in contracts, and availability of having automated contract testing through Mocha and Chai JavaScript test framework. In the scope of this project, we decided to start our implementation in Truffle framework. One of the main reason was due to the advantage of Truffle having a wider and active community support and availability of online resources, than any other Ethereum development frameworks. Moreover, the possibility of truffle integration with NodeJS became an important and crucial advantage for our implementation due to our team’s advanced skills on JavaScript. [citation] programming.

\subparagraph{Ganache}
It originates from the former known TestRPC,  which was a local (virtual) Ethereum blockchain for development purposes. It simulates the blockchain network, allowing you to make RPC calls in it without the need of actually mining the blocks. Ganache was developed by Truffle and is included in their latest development in Truffle Suite. The release of Ganache was positively anticipated across the whole Truffle framework, specifically in performance aspects - being much faster. Moreover, a huge advantage was providing an interface to the developer with the details of all the transactions being mined and their costs which further improved the user experience of the whole development platform itself [citation]


\subsubsection{Node.js, Express and Web3.js}

\subparagraph{Node.js}
Being an open source cross-platform based on Chrome's JavaScript runtime for effortlessly constructing quick, scalable applications. Node.js utilizes an event driven, non-blocking I/O model which that makes it lightweight and effective, ideal for data-intensive real-time applications that keep running throughout distributed devices. Through event-driven property, meaning that the server reacts at the time when an event occurs therefore allowing us to create easily scalable, fast and real-time applications.[citation]

\subparagraph{Express}

Being a project from a node.js foundation, which is a quick, moderate web application framework for Node.js. It is intended for building web applications and is the true standard server system for Node.js. In the scope of our project we use Express as a basic routing layer built over the base of Node.js HTTP server that manages a server and the routes. It gives declarative routing without the need of doing “switch” or “if” statements or any additional functions, into a fundamental middleware design. [citation]

\subparagraph{Web3.js}
An aggregation of libraries which contain specific functionality for the ethereum environment and enables you to interact with a local or remote ethereum node, utilizing a HTTP or IPC connection [citation]



\subsubsection{PostgreSQL and Sequelize}
\subparagraph{PostgreSQL}
An open source and highly scalable object-relational database system, which runs on all major operating systems including Linux, UNIX (AIX, BSD, HP-UX, macOS, Solaris), and Windows. It is completely ACID obedient, has full assistance for foreign keys, joins, views, triggers. [citation]

\subparagraph{Sequelize}
A promise-based Node.js ORM for PostgreSQL, MySQL, SQLite and Microsoft SQL Server. It highlights strong transaction support, relations, read replication etc. [citation]


\subsubsection{Build-up/ Deployment Tools}
\subparagraph{Docker}
A deployment tool intended to make it less demanding to create, deploy, and run applications by using containers. Containers enable a developer to bundle up an application with all the parts it needs, such as libraries and different dependencies, and deliver everything out as one package. Thusly, because of the container, the developer can be certain that the application will run the same way on other machines, independently of their different operating system or any customized settings that the other machine may have. This gives a huge performance boost and decreases the extent and the size of the applications itself. [citation]
